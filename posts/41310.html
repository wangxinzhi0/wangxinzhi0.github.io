<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta name="keywords" content="Git教程, 志其余年"><meta name="description" content="个人技术博客"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><title>Git教程 | 志其余年</title><link rel="icon" type="image/png" href="https://cdn.jsdelivr.net/gh/wangxinzhi0/PicX-image@master/hexo/logo.1spkqairezog.png"><link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css"><link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css"><link rel="stylesheet" type="text/css" href="/libs/aos/aos.css"><link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css"><link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" type="text/css" href="/css/matery.css"><link rel="stylesheet" type="text/css" href="/css/my.css"><script src="/libs/jquery/jquery.min.js"></script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="志其余年" type="application/atom+xml"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><style>body{background-image:url(https://cdn.jsdelivr.net/gh/Tokisaki-Galaxy/res/site/medias/background.jpg);background-repeat:no-repeat;background-size:cover;background-attachment:fixed}</style><body><script>("1"===localStorage.getItem("dark")||matchMedia("(prefers-color-scheme: dark)").matches)&&document.body.classList.add("dark")</script><a onclick="switchNightMode()" id="sma"><i class="fa fa-moon-o" id="nightMode" aria-hidden="true"></i></a><script type="text/javascript">var st,OriginTitile=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="≥Ö‿Ö≤ 网页崩溃了！",clearTimeout(st)):(document.title="≥◔◡◔≤ 皮一下，很开心！",st=setTimeout(function(){document.title=OriginTitile},3e3))})</script><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/" class="waves-effect waves-light"><img src="https://cdn.jsdelivr.net/gh/wangxinzhi0/PicX-image@master/hexo/logo.1spkqairezog.png" class="logo-img" alt="LOGO"> <span class="logo-span">志其余年</span></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/" class="waves-effect waves-light"><i class="fas fa-home" style="zoom:.6"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fas fa-tags" style="zoom:.6"></i> <span>标签</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fas fa-bookmark" style="zoom:.6"></i> <span>分类</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fas fa-archive" style="zoom:.6"></i> <span>归档</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/about" class="waves-effect waves-light"><i class="fas fa-user-circle" style="zoom:.6"></i> <span>关于</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fas fa-comments" style="zoom:.6"></i> <span>留言板</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fas fa-address-book" style="zoom:.6"></i> <span>友情链接</span></a></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fas fa-search" title="搜索" style="zoom:.85"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><img src="https://cdn.jsdelivr.net/gh/wangxinzhi0/PicX-image@master/hexo/logo.1spkqairezog.png" class="logo-img circle responsive-img"><div class="logo-name">志其余年</div><div class="logo-desc">个人技术博客</div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/" class="waves-effect waves-light"><i class="fa-fw fas fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="/tags" class="waves-effect waves-light"><i class="fa-fw fas fa-tags"></i> 标签</a></li><li class="m-nav-item"><a href="/categories" class="waves-effect waves-light"><i class="fa-fw fas fa-bookmark"></i> 分类</a></li><li class="m-nav-item"><a href="/archives" class="waves-effect waves-light"><i class="fa-fw fas fa-archive"></i> 归档</a></li><li class="m-nav-item"><a href="/about" class="waves-effect waves-light"><i class="fa-fw fas fa-user-circle"></i> 关于</a></li><li class="m-nav-item"><a href="/contact" class="waves-effect waves-light"><i class="fa-fw fas fa-comments"></i> 留言板</a></li><li class="m-nav-item"><a href="/friends" class="waves-effect waves-light"><i class="fa-fw fas fa-address-book"></i> 友情链接</a></li></ul></div></div></nav></header><div class="bg-cover pd-header post-cover" style="background-image:url(https://cdn.jsdelivr.net/gh/wangxinzhi0/PicX-image@master/hexo/4.t68e0lf94i8.jpg)"><div class="container" style="right:0;left:0"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">Git教程</h1></div></div></div></div></div><main class="post-container content"><link rel="stylesheet" href="/libs/tocbot/tocbot.css"><style>#articleContent h1::before,#articleContent h2::before,#articleContent h3::before,#articleContent h4::before,#articleContent h5::before,#articleContent h6::before{display:block;content:" ";height:100px;margin-top:-100px;visibility:hidden}#articleContent :focus{outline:0}.toc-fixed{position:fixed;top:64px}.toc-widget{width:345px;padding-left:20px}.toc-widget .toc-title{padding:35px 0 15px 17px;font-size:1.5rem;font-weight:700;line-height:1.5rem}.toc-widget ol{padding:0;list-style:none}#toc-content{padding-bottom:30px;overflow:auto}#toc-content ol{padding-left:10px}#toc-content ol li{padding-left:10px}#toc-content .toc-link:hover{color:#42b983;font-weight:700;text-decoration:underline}#toc-content .toc-link::before{background-color:transparent;max-height:25px;position:absolute;right:23.5vw;display:block}#toc-content .is-active-link{color:#42b983}#floating-toc-btn{position:fixed;right:15px;bottom:76px;padding-top:15px;margin-bottom:0;z-index:998}#floating-toc-btn .btn-floating{width:48px;height:48px}#floating-toc-btn .btn-floating i{line-height:48px;font-size:1.4rem}</style><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"><a href="/tags/Git/"><span class="chip bg-color">Git</span></a></div></div><div class="col s5 right-align"><div class="post-cate"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/" class="post-category">代码管理工具</a></div></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp; 2021-04-19</div><div class="post-date info-break-policy"><i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp; 2021-08-07</div><div class="info-break-policy"><i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp; 14.4k</div><div class="info-break-policy"><i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp; 54 分</div><div id="busuanzi_container_page_pv" class="info-break-policy"><i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp; <span id="busuanzi_value_page_pv"></span></div></div></div><hr class="clearfix"><div class="card-content article-card-content"><div id="articleContent"><p>参考<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰Git教程</a>、<a target="_blank" rel="noopener" href="https://www.runoob.com/git/git-tutorial.html">菜鸟教程Git教程</a></p><h2 id="1-Git简介"><a href="#1-Git简介" class="headerlink" title="1.Git简介"></a>1.Git简介</h2><h3 id="Git的功能"><a href="#Git的功能" class="headerlink" title="Git的功能"></a>Git的功能</h3><p><code>Git</code>是目前世界上最先进的<strong>分布式版本控制系统</strong>（没有之一），高端大气上档次！</p><p>什么是版本控制系统？</p><ul><li>如果你用<code>Word</code>写过长篇大论(毕业论文)，你可能需要修改很多版本，保存一堆文件，过了一段时间，你想找回之前的某个版本，但是已经记不清它的位置了，只好一个一个查找，很麻烦。想只保留最新版本，却怕之前版本还会用到，不敢删除，真郁闷！</li><li>更要命的是，如果是多人协作，你需要将<code>Word</code>发给同事，你修改的<code>Word</code>和同事修改的<code>Word</code>要手动合并，非常困难。</li></ul><p>于是，如果有一个软件可以自动帮我们记录每次文件的改动，还可以让同事协作编辑，这样自己就不需要管理一堆各种版本文件了，也不需要把文件传来传去。如果想查看某次改动，只需要在软件里瞄一眼就可以。恭喜你，<code>Git</code>就能完成这项工作。</p><p><img src="https://cdn.jsdelivr.net/gh/wangxinzhi0/PicX-image@master/Git/1.6fpan38ofig0.png" alt="1"></p><h3 id="Git安装和配置"><a href="#Git安装和配置" class="headerlink" title="Git安装和配置"></a>Git安装和配置</h3><p>这里以<code>Windows</code>操作系统为例（其他操作系统自行百度），首先从Git官网<a target="_blank" rel="noopener" href="https://git-scm.com/downloads">下载安装程序</a>，默认安装即可。<strong>安装</strong>完桌面右击可以看到<code>Git GUI Here</code>和<code>Git Bash Here</code>即为成功。</p><p>安装完成后，还需要进一步<strong>配置机器身份</strong>，你的名字和邮箱，键入以下两行命令。你无需担心别人冒充名字和邮箱，首先大家都是善良的小伙伴，其次，真的存在冒充也有法可查。</p><pre class="language-yaml"><code class="language-yaml">git config <span class="token punctuation">-</span><span class="token punctuation">-</span>global user.name "Your Name"//配置姓名
git config <span class="token punctuation">-</span><span class="token punctuation">-</span>global user.email "Your Email"//配置邮箱
</code></pre><p>键入如下命令可以<strong>查看配置结果</strong>。</p><pre class="language-yaml"><code class="language-yaml">git config <span class="token punctuation">-</span><span class="token punctuation">-</span>list//查看配置结果
</code></pre><p><strong>注意</strong>：<code>git config</code>命令的<code>--global</code>参数，用了它表示这台机器上的所有<code>Git</code>仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和<code>Email</code>地址。</p><h3 id="Git工作区、暂存区、版本库"><a href="#Git工作区、暂存区、版本库" class="headerlink" title="Git工作区、暂存区、版本库"></a>Git工作区、暂存区、版本库</h3><p>我们理解下Git的基本概念：</p><ul><li><strong>工作区</strong>：就是你在电脑里看到的目录</li><li><strong>暂存区</strong>：英文<code>stage</code>或<code>index</code>，一般存放在<code>.git</code>（<code>git init</code>后生成的目录）目录下的<code>index</code>文件中，所以有时也称索引(<code>index</code>)</li><li><strong>版本库</strong>：工作区有一个隐藏目录<code>.git</code>，是<code>Git</code>的版本库</li></ul><p><img src="https://cdn.jsdelivr.net/gh/wangxinzhi0/PicX-image@master/Git/2.2vhljm6j5u60.png" alt="2"></p><h2 id="2-时空机穿梭"><a href="#2-时空机穿梭" class="headerlink" title="2.时空机穿梭"></a>2.时空机穿梭</h2><h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><p>版本库，又称仓库，英文(<strong>repository</strong>)。你可以简单的理解成一个目录，这个目录里所有文件都可以被<code>Git</code>管理起来，每个文件的修改、删除，<code>Git</code>都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p><p><strong>方法一</strong>：<code>git init</code></p><p><code>Git</code>通过<code>git init</code>命令初始化一个<code>git</code>仓库，可以在空目录或存在内容的目标执行，会在目录下生成一个.git目录（是隐藏目录），<code>.git</code>目录用了跟踪管理版本库，没事千万不要修改。</p><pre class="language-YAML"><code class="language-YAML">git init//在当前目录初始化仓库
git init 指定目录//在指定目录初始化仓库
</code></pre><p>初始化仓库之后，可以在仓库存放数据和资源。使用下面两条命令提交修改到本地版本库。</p><pre class="language-YAML"><code class="language-YAML">git add Git.md//提交修改内容Git.md到暂存区
git add . //提交仓库所有修改内容到暂存区
git commit -m "message" //提交暂存区所有内容到本地版本库
</code></pre><p>使用<code>git status</code>查看仓库当前状态，显示有变更的文件。</p><pre class="language-YAML"><code class="language-YAML">git status//查看仓库当前状态
</code></pre><p><strong>方法二</strong>：<code>git clone</code></p><p>当然，你也可以充现有<code>Git</code>仓库拷贝项目，使用<code>git clone</code>命令。</p><pre><code>git clone Git仓库 本地目录//例如：git clone git://github.com/schacon/grit.git mygrit
</code></pre><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>我们多次修改提交之后，版本控制系统肯定记得我们修改了什么内容，查看版本历史记录的命令为<code>git log</code>。该命令显示最近到最远的提交日志，如果嫌输出信息太多，可以加上<code>--pretty=oneline</code>参数。</p><pre class="language-YAML"><code class="language-YAML">git log//显示提交日志，由近及远
git log --pretty=oneline//单行显示提交日志，由近及远
</code></pre><p>单行显示是，前面一大串字符为<code>commit id</code>(版本号)，唯一的。</p><p><code>Ok</code>，知道了怎么看提交历史，我们现在想要回退版本，用<code>git reset</code>命令实现。首先，<code>Git</code>必须直到当前版本是哪个版本，<code>Git</code>中，<code>HEAD</code>指向表示当前版本，上一个版本为<code>HEAD^</code>，上上一个版本为<code>HEAD^^</code>，当然<code>^</code>太多的话打起来不方便，用<code>HEAD~50</code>表示回退<code>50</code>个版本。</p><pre class="language-YAML"><code class="language-YAML">git reset --hard HEAD^//HEAD指向当前版本，回退到上一个版本
</code></pre><p><code>--hard</code>参数的意义后面再讲。</p><p>回退到上一个版本之后，提交日志就不显示回退之前的那个版本了，我们还能回到回退之前吗？当然可以，这时需要<code>git reflog</code>命令显示每一次提交日志，找到<code>commit id</code>即可使用<code>git reset</code>命令回到未来了。</p><pre class="language-YAML"><code class="language-YAML">git reflog//显示所有提交历史
git reset --hard commit_id//回到未来的某个版本
</code></pre><h3 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h3><p><code>Git</code>为什么比其他版本控制系统设计的优秀呢？这主要得益于<code>Git</code><strong>跟踪管理的是修改</strong>，而非文件。每次修改，如果不<code>git add</code>添加到暂存区，那么就不会加到<code>commit</code>中。</p><p>例如你做了如下操作：</p><ul><li>第一次修改-&gt;<code>git add</code>-&gt;第二次修改-&gt;<code>git commit</code>，这样第二次修改不会被提交，因为<code>git commit</code>只负责把暂存区的修改提交了。</li></ul><p>你可以修改一次<code>git add</code>一次到暂存区，最后<code>git commit</code>提交，也可以几次修改后<code>git add</code>然后<code>git commit</code>，将几次修改合并后一块提交。</p><p>提交后，用<code>git diff</code>可以查看文件差别。</p><pre class="language-YAML"><code class="language-YAML">git diff HEAD --readme.txt//查看工作区和版本库里最新版本的区别
</code></pre><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><p><strong>场景一</strong>：命令<code>git checkout --readme.txt</code>可以<strong>把该文件在工作区的修改全部撤销</strong>，这里有两种情况：</p><ul><li><code>readme.txt</code>自修改后还没有放到暂存区，现在撤销修改就回到和版本库一模一样的状态</li><li><code>readme.txt</code>已经添加到暂存区，又做了修改，现在撤销修改就回到添加暂存区后的状态</li></ul><p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p><pre class="language-YAML"><code class="language-YAML">git checkout --readme.txt//将文件回到最近一次git commit或git add时的状态
</code></pre><p>注意：<code>git checkout --file</code>命令中的<code>--</code>很重要，没有它就变成了了切换到另一个分支的命令，后面分支管理再讲述<code>git checkout</code>命令。</p><p><strong>场景二</strong>：如果<strong>已经将修改添加到暂存区</strong>，但是还没有<code>commit</code>，可以使用<code>git reset HEAD &lt;file&gt;</code>把暂存区的修改撤销掉，重新放回到工作区。</p><pre class="language-YAML"><code class="language-YAML">git reset HEAD readme.txt//把文件暂存区修改回退到工作区
</code></pre><p><code>git reset</code>命令不仅可以回退版本，也可以吧暂存区的修改回退到工作区，当我们使用<code>HEAD</code>是，表示最新版本。</p><p>还记得如何丢弃工作区的修改吗？</p><p><strong>场景三</strong>：<strong>已经提交了不合适的修改到版本库时</strong>，想要撤销本次提交，参考「版本回退」一节，<code>git reset --hard commit_id</code>，前提是没有推送到远程库。</p><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>在<code>Git</code>中，删除也是一个修改操作。</p><p>首先添加一个<code>test.txt</code>文件并提交到仓库，一般情况下，直接在文件管理器中删除文件，此时<code>git status</code>看到<code>Git</code>提示你删除了文件，工作区和版本库不一致了。现在你有两种选择：</p><ul><li>确实要删除该文件，那就用<code>git rm</code>删掉，并且<code>git commit</code></li></ul><pre class="language-YAML"><code class="language-YAML">git rm test.txt//将文件从暂存区和工作区删除
git commit -m "remove test.txt"
</code></pre><ul><li>删错了，因为版本库还有呢，所以可以轻松的使用工作区撤销修改恢复到最新版本</li></ul><pre class="language-YAML"><code class="language-YAML">git checkout --test.txt//撤销工作区修改（删除）
</code></pre><p>注意：<code>git checkout</code>其实是用版本库里的版本替换工作区的版本，物理工作区是修改还是删除，都可以“一键还原”。从来没有添加到版本库就被删除的文件，是无法恢复的！</p><h2 id="3-远程仓库"><a href="#3-远程仓库" class="headerlink" title="3.远程仓库"></a>3.远程仓库</h2><p>准备工作，注册<code>Github</code>，关联<code>Git</code>和<code>Github</code>：</p><ul><li>运行如下命令，按几次<code>Enter</code>结束运行，会自动的在用户目录<code>C:\Users\WXZ\</code>生成一个“.ssh”的目录，里面会保存有两个文件：私钥（<code>id_rsa</code>）、公钥（<code>id_rsa.pub</code>）</li></ul><pre class="language-YAML"><code class="language-YAML">ssh-keygen -t rsa -C "your email"//Github邮箱
</code></pre><ul><li>打开<code>Github</code>主页，点击右上角头像，选择<code>settings</code>，将公钥内容复制到<code>SSH</code>，名称随意设置，如下图</li></ul><p><img src="https://cdn.jsdelivr.net/gh/wangxinzhi0/PicX-image@master/Git/3.z8izwrj15w0.png" alt="3"></p><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><p>现在的场景是，你已经在本地创建了一个<code>Git</code>仓库，又想在<code>Github</code>创建一个<code>Git</code>仓库，并且让这两个仓库进行远程同步，这样，<code>Github</code>上的仓库既可以作为备份，又可以让其他人通过该仓库协作，真是一举多得。</p><p>在Github上创建一个空仓库，根据它的提示在本地仓库运行如下命令。</p><pre class="language-YAML"><code class="language-YAML">git remote add origin <远程库地址>//关联本地仓库到远程库地址
git push -u origin master//把本地库所有内容推送到远程库上
</远程库地址></code></pre><p>远程库的名字是<code>origin</code>，<code>Git</code>默认叫法，可以改成其他名字。</p><p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。由于远程库是空的，我们第一次推送<code>master</code>分支是，加上了<code>-u</code>参数，<code>Git</code>不但会把本地的<code>master</code>分支内容推送到远程新的<code>master</code>分支，还会把本地<code>master</code>和远程<code>master</code>分支关联起来，之后的推送或者拉取是就可以简化命令。</p><p>推送成功之后，<code>Github</code>页面看到远程库的内容和本地一模一样。之后本地提交可以通过命令：</p><pre class="language-YAML"><code class="language-YAML">git push origin master//把本地master分支的最新修改推送至Github
</code></pre><p><strong>注意</strong>：第一次使用<code>Git</code>的<code>clone</code>或者<code>push</code>命令连接<code>Github</code>时，会得到一个<code>SSH</code>警告，输入<code>yes</code>回车即可。</p><h3 id="删除远程仓库"><a href="#删除远程仓库" class="headerlink" title="删除远程仓库"></a>删除远程仓库</h3><p>如果添加远程仓库写错了，或者就是想要删除远程库，可以用<code>git remote rm &lt;name&gt;</code>命令。使用前，建议用<code>git remote -v</code>查看远程库信息，然后根据名字删除。</p><pre class="language-YAML"><code class="language-YAML">git remote -v//查看远程库信息
git remote rm origin//删除远程仓库，其实解除本地和远程的绑定关系
</code></pre><p>此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到<code>GitHub</code>，在后台页面找到删除按钮再删除。</p><p>从远程库克隆</p><p>之前是先有本地库，后有远程库的时候，如何关联远程库。现在，假设我们从零开发，那么最好的方式是先创建远程库，然后从远程库克隆。</p><ul><li><p>首先，登录<code>Github</code>，创建一个新的仓库，勾选自动创建<code>README.md</code>文件</p></li><li><p>然后，使用<code>git clone</code>克隆本地库</p></li></ul><p>如果有多人协作开发，那么每个人各自从远程克隆一份就可以了。你可能注意到，<code>Github</code>给出的克隆地址不止一个，实际上<code>Git</code>支持多种协议，<code>git://</code>使用<code>ssh</code>，<code>https://</code>使用<code>https</code>等其他协议，使用https协议除了速度慢以外，还有个最大的麻烦就是每次推送都必须输入口令。但在某些只开放<code>http</code>端口的公式内部就无法使用<code>ssh</code>协议二只能用<code>https</code>。</p><h2 id="4-分支管理"><a href="#4-分支管理" class="headerlink" title="4.分支管理"></a>4.分支管理</h2><p><strong>分支就是科幻电影里的平行宇宙</strong>，当你正在电脑前努力学习<code>Git</code>的时候，另一个你正在另一个平行宇宙里努力学习<code>SVN</code>。如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了<code>Git</code>又学会了<code>SVN</code>！</p><p>分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了<code>50%</code>的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p><p>现在有了分支，就不用怕了。你<strong>创建了一个属于你自己的分支</strong>，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，<strong>再一次性合并到原来的分支上</strong>，这样，<strong>既安全，又不影响别人工作</strong>。</p><h3 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h3><p>首先，<strong>创建dev分支</strong>，然后<strong>切换到dev分支</strong>：</p><pre class="language-YAML"><code class="language-YAML">git checkout -b dev//创建并切换到dev分支
</code></pre><p><code>git checkout</code>命令加上<code>-b</code>参数表示创建并切换，相当于一下两条命令</p><pre class="language-YAML"><code class="language-YAML">git branch dev//创建dev分支
git checkout dev//切换到dev分支
</code></pre><p>然后，用<code>git branch</code>命令查看当前分支，该命令会列出所有分支，当前分支前面会标有一个*号。</p><pre class="language-YAML"><code class="language-YAML">git branch//查看所有分支，当前分支标有*号
</code></pre><p>然后，我们可以在<code>dev</code>分支上正常提交，完成<code>dev</code>分支工作后，我们可以切换回<code>master</code>分支</p><pre class="language-YAML"><code class="language-YAML">git add readme.txt//dev分支正常提交
git commit -m "branch test"
git checkout master//切换回master分支
</code></pre><p>切换回<code>master</code>分支后，刚才的<code>readme.txt</code>文件修改不见了！因为刚才的提交在<code>dev</code>分支上，而<code>master</code>分支此刻的提交点没有变。</p><p><img src="https://cdn.jsdelivr.net/gh/wangxinzhi0/PicX-image@master/Git/4.ft1f3ath734.png" alt="4"></p><p>现在，我们<strong>把dev分支的工作成果合并到master分支上</strong>：</p><pre class="language-YAML"><code class="language-YAML">git merge dev//dev分支合并到master上
</code></pre><p><code>git merge</code>命令用于合并指定分支到当前分支。合并后，再查看<code>readme.txt</code>的内容，就可以看到和<code>dev</code>分支最新提交是完全一样的。</p><p>注意到上面命令会提示<code>Fast-forward</code>信息，<code>Git</code>告诉我们，<strong>这次合并是“快进模式”</strong>，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快。当然，也不是每次合并都能<code>Fast-forward</code>，我们后面会讲其他方式的合并。</p><p><strong>合并完成后，我们就可以放心的删除dev分支了</strong>，删除后，查看<code>branch</code>，就只剩下<code>master</code>分支了。</p><pre class="language-YAML"><code class="language-YAML">git branch -d dev//删除dev分支
git branch//查看分支
</code></pre><p>因为创建、合并、删除分支非常快，所以<code>Git</code>鼓励你使用分支完成某个任务，合并后再删除掉分支，这和直接在<code>master</code>分支上工作效果是一样的，但过程更加安全。</p><p><strong>切换分支的优雅方式</strong>：<code>switch</code></p><p>切换分支使用<code>git checkout &lt;branch&gt;</code>，前面的撤销修改则是<code>git checkout --&lt;file&gt;</code>，同一个命令，有两种作用，确实有点让人迷惑。</p><p>实际上，切换分支这个动作，用switch更科学，因此最新版本的Git提供了git switch命令来切换分支：</p><pre class="language-YAML"><code class="language-YAML">git switch -c dev//创建并切换分支
git switch master//直接切换到已有分支
</code></pre><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>人生不如意十之八九，合并分支往往也不是一帆风顺的。</p><p>创建新分支<code>feature1</code>并开发提交，然后切换到<code>master</code>分支开发并提交。这时候<code>master</code>分支和<code>feature1</code>分支都有了新的提交，<code>Git</code>无法进行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突。</p><pre class="language-YAML"><code class="language-YAML">git switch -c feature1//创建并切换分支
git add readme.txt//feature1分支开发提交
git commit -m "feature1分支开发"
    
git switch master//切换到master分支
git add readme.txt//master分支开发提交
git commit -m "master分支开发"
    
git merge feature1//在master分支上合并feature1分支
</code></pre><p><img src="https://cdn.jsdelivr.net/gh/wangxinzhi0/PicX-image@master/Git/5.5hg17zkrljw0.png" alt="5"></p><p>执行<code>git merge</code>果然发生了冲突，需要手动解决冲突后再提交。通过<code>git status</code>查看冲突文件。<code>Git</code>用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记不同分支的内容，将在<code>master</code>分支将冲突文件做修改后再次提交，之后再合并。</p><pre class="language-yaml"><code class="language-yaml">git add readme.txt//master分支冲突修改提交
git commit <span class="token punctuation">-</span>m "conflict fixed"
git merge feature1//合并分支
git branch <span class="token punctuation">-</span>d feature1//删除feature1分支
</code></pre><p><img src="https://cdn.jsdelivr.net/gh/wangxinzhi0/PicX-image@master/Git/6.2xd8r8m10o60.png" alt="6"></p><p>用带参数<code>--graph</code>的<code>git log</code>也可以查看分支合并情况</p><pre class="language-yaml"><code class="language-yaml">git log <span class="token punctuation">-</span><span class="token punctuation">-</span>graph <span class="token punctuation">-</span><span class="token punctuation">-</span>pretty=oneline <span class="token punctuation">-</span><span class="token punctuation">-</span>abbrev<span class="token punctuation">-</span>commit//查看分支合并情况
</code></pre><h3 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h3><p>通常，合并分支时，<code>Git</code>会用<code>Fast forward</code>模式，但在这种模式下，删除分之后，会丢掉分支信息。</p><p>如果要强制禁用<code>Fast forward</code>模式，Git就会在<code>merge</code>时生成一个新的<code>commit</code>，这样，从分支历史上就可以看出分支信息。</p><p>下面实战一下<code>--no-ff</code>方式的<code>git merge</code></p><p>首先，仍然创建并切换<code>dev</code>分支，修改readme.txt文件并提交新的<code>commit</code>，然后切回到<code>master</code>分支。采用<code>--no-ff</code>参数合并分支，表示禁用<code>Fast forward</code>，因此本次合并要创建一个新地<code>commit</code>，所以要加上<code>-m</code>参数，把<code>commit</code>描述写进去。合并后，我们用git log查看分支历史。</p><pre class="language-yaml"><code class="language-yaml">git switch <span class="token punctuation">-</span>c dev//创建并切换分支
git add readme.txt//提交commit
git commit <span class="token punctuation">-</span>m "add merge"
git switch mater//切回master分支
git merge <span class="token punctuation">-</span><span class="token punctuation">-</span>no<span class="token punctuation">-</span>ff <span class="token punctuation">-</span>m "merge with no<span class="token punctuation">-</span>ff" dev//禁用Fast forward合并分支dev
git log <span class="token punctuation">-</span><span class="token punctuation">-</span>graph <span class="token punctuation">-</span><span class="token punctuation">-</span>pretty=oneline <span class="token punctuation">-</span><span class="token punctuation">-</span>abbrev<span class="token punctuation">-</span>commit//查看分支历史
</code></pre><p><img src="https://cdn.jsdelivr.net/gh/wangxinzhi0/PicX-image@master/Git/7.680m0tg8xic0.png" alt="7"></p><p><strong>分支策略</strong></p><p>在实际开发中，我们应该<strong>按照几个基本原则进行分支管理</strong>：</p><ul><li>首先<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</li><li>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如<code>1.0</code>版本法布施，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布<code>1.0</code>版本；</li><li>你和你的小伙伴每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</li></ul><p>所以<strong>团队分支看起来像这样</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/wangxinzhi0/PicX-image@master/Git/8.5fcbcechijc0.png" alt="8"></p><p><code>Git</code>十分强大，在团队开发中应该充分应用。合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</p><h3 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h3><p>软件开发中，<code>bug</code>就像家常便饭一样，有了<code>bug</code>就需要修复，在<code>Git</code>中，由于分支是如此强大，所以<strong>每个<code>bug</code>都可以通过一个新的临时分支来修复</strong>，修复后，合并分支，然后将临时分支删除。</p><p>当你接到一个代号<code>101</code>的<code>bug</code>任务时，很自然地，你想创建一个分支<code>issue-101</code>来修复它，但是，等等，当前你在<code>dev</code>上进行的工作还没有提交，并不是你不想提交，而是工作还未完成，但是<code>bug</code>必须在<code>2h</code>内修复，怎么办？</p><p>幸好，<code>Git</code>还提供了一个<code>stash</code>功能，可以<strong>把当前工作现场储藏起来</strong>，等以后恢复现场后继续工作。</p><pre class="language-YAML"><code class="language-YAML">git stash//把当前工作现场存储起来
git status//此时工作区就是干净的，可以方向创建分支修复bug
</code></pre><p>首先确定在拿个分支上修复<code>bug</code>，假定在<code>master</code>分支上修复，就从<code>master</code>创建临时分支，切换到<code>issue-101</code>修复<code>bug</code>，然后提交，修复完成后切回<code>master</code>分支，完成合并，最后删除<code>issue-101</code>分支。</p><pre class="language-YAML"><code class="language-YAML">git switch master
git switch -c issue-101
git add readme.txt
git commit -m "fix bug 101"
git switch master
git merge --no-ff -m "merged bug fix 101" issue-101
git branch -d issue-101
</code></pre><p>修复完<code>bug</code>，现在是时候回到<code>dev</code>分支干活了。工作区是干净的，刚才的工作现场保存到哪里去了？用<code>git stash list</code>命令看看：</p><pre class="language-YAML"><code class="language-YAML">git switch dev
git status
git stash list
</code></pre><p>工作现场还在，<code>Git</code>把<code>stash</code>内容存在某个地方了，但是需要恢复一下，有两个办法：</p><ul><li>一是用<code>git stash apply</code>恢复，但是恢复后，<code>stash</code>内容并不删除，你需要用<code>git stash drop</code>来删除</li><li>二是用<code>git stash pop</code>，恢复的同时把<code>stash</code>内容也删除了。</li></ul><pre class="language-YAML"><code class="language-YAML">git stash pop//恢复现场，删除stash内容
git stash list//再次查看stash内容
</code></pre><p>如果有多次<code>stash</code>，恢复的时候，先用<code>git stash list</code>查看，然后恢复指定的<code>stash</code>，用命令：</p><pre class="language-YAML"><code class="language-YAML">git stash list
git stash apply stash@&#123;0&#125;//恢复到指定的stash
</code></pre><p>在<code>master</code>分支上修复了<code>bug</code>后，我们要想一想，<code>dev</code>分支时早期从master分支分出来的，所以这个<code>bug</code>其实在当前<code>dev</code>分支上也存在。</p><p>那么怎么在<code>dev</code>分支上修复同样的<code>bug</code>？重复操作一次，提交不就行了？有没有更简单的方法？当然！</p><p><strong>同样的<code>bug</code>，要在dev上修复</strong>，我们只需要把<code>4c805e2 fix bug 101</code>这个提交所做的修改“复制”到<code>dev</code>分支，提交信息在修复<code>bug</code>分支提交时出现。注意：我们只想复制<code>4c805e2 fix bug 101</code>这个提交所做的修改，并不是把整个<code>master</code>分支<code>merge</code>过来。</p><p>为了方便操作，<code>Git</code>专门提供了一个<code>cherry-pick</code>命令，让我们能<strong>复制一个特定的提交到当前分支</strong>。</p><pre class="language-YAML"><code class="language-YAML">git branch//查看当前分支
git cherry-pick 4c805e2//复制特定提交到当前分支
</code></pre><p><code>Git</code>自动给<code>dev</code>分支做了一次提交，注意这次提交的<code>commit</code>是<code>1d4b803</code>，它不同于<code>4c805e2</code>，因为这两个<code>commit</code>只是改动相同，但确实是两个不同的<code>commit</code>，用<code>git cherry-pick</code>，我们就不需要在<code>dev</code>分支上手动再把<code>bug</code>的过程重复一遍。</p><p><strong>有些聪明的同学会想了</strong>，既然可以在<code>master</code>分支上修复<code>bug</code>后，在<code>dev</code>分支上可以“重放”这个修复过程，那么直接在<code>dev</code>分支上修复<code>bug</code>，然后在<code>master</code>分支上“重放”行不行？当然可以，不过你仍然需要<code>git stash</code>命令保存现场，才能从<code>dev</code>分支切换到<code>master</code>分支。</p><h3 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h3><p>软件开发中，总有无穷无尽的新功能不断添加进来。</p><p>添加一个新功能时，<strong>你肯定不希望因为一些实验性质的代码，把主分支搞乱了</strong>，所以，每添加一个新功能，最后新建一个<code>feature</code>分支，在上面开发，完成后，合并，最后，删除该<code>feature</code>分支。</p><p>现在，你终于接到了一个新任务：开发代号为<code>Vulcan</code>的新功能，该功能计划用于下一代星际飞船。开发完毕，切回<code>dev</code>，准备合并。</p><pre class="language-YAML"><code class="language-YAML">git switch -c feature-vulcan//创建新feature分支
git add vulcan.py//开发完毕提交
git status
git commit -m "add feature vulcan"
</code></pre><p>一切顺利的话，<code>feature</code>分支和<code>bug</code>分支是类似的，合并，然后删除。但是！！！就在此时，接到上级命令，因为经费不足，新功能必须取消！虽然白干了，但是这个包含机密资料的分支还是必须就地销毁：</p><pre class="language-YAML"><code class="language-YAML">git switch dev
git branch -d feature-vulcan
</code></pre><p>销毁失败，<code>Git</code>友情提示，<code>feature-vulcan</code>分支还没有合并，如果删除，将丢失掉修改，如果强行删除，需要使用大写的<code>-D</code>参数，现在我们强行删除，终于删除成功！</p><pre class="language-YAML"><code class="language-YAML">git branch -D feature-vulcan//强行删除未合并分支
</code></pre><h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><p>当你从远程仓库克隆时，实际上<code>Git</code>自动把本地的<code>master</code>非分之和远程的<code>master</code>分支对应起来了，并且，远程仓库的默认名称是<code>origin</code>。要查看远程仓库的信息，用<code>git remote</code>或者<code>git remote -v</code>显示更详细的信息。</p><p>上面显示了可以抓取和推送的<code>origin</code>的地址。如果没有推送权限，就看不到<code>push</code>的地址。</p><pre class="language-YAML"><code class="language-YAML">git remote//查看远程库信息
git remote -v
</code></pre><p><strong>推送分支</strong></p><p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，<code>Git</code>就是把该分支推送到远程库对应的远程分支上：</p><pre class="language-YAML"><code class="language-YAML">git push origin master//推送到远程master分支
git push origin dev//推送到远程dev分支
</code></pre><p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p><ul><li><code>master</code>分支是主分支，因此要时刻与远程同步；</li><li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li><li><code>bug</code>分支只用于在本地修复<code>bug</code>，就没必要推送到远程了，出发老板要看看你每周到底修复了几个<code>bug</code>；</li><li><code>feature</code>分支是否推送到远程，取决于你是否和你的小伙子合作在上面开发。</li></ul><p>总之，就是<code>Git</code>中，分支完全可以在本地自己藏着完，是否推送，视你的心情而定！</p><p><strong>抓取分支</strong></p><p>多人协作，大家都会往<code>master</code>和<code>dev</code>分支上推送各自的修改。</p><p>现在，模拟一个你的小伙伴，可以在另一个电脑（注意要把<code>SSH Key</code>添加到<code>GitHub</code>）或者同一台电脑的另一个目录下克隆。当你的小伙伴从远程库克隆时，默认情况下，你的小伙伴只能看到本地的<code>master</code>分支，不信可以用<code>git branch</code>命令看看。</p><pre class="language-YAML"><code class="language-YAML">git clone <url>//克隆仓库
git branch//查看分支
</url></code></pre><p>现在，你的小伙伴要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地，于是他用这个命令创建本地<code>dev</code>分支。现在，他就可以在<code>dev</code>上继续修改，然后，时不时地<code>dev</code>分支<code>push</code>到远程。</p><pre class="language-YAML"><code class="language-YAML">git switch -c dev origin/dev //创建远程origin的dev分支到本地
git add env.txt
git commit -m "add env"
git push origin dev//dev分支开发推送到远端
</code></pre><p>你的小伙伴已经向<code>origin/dev</code>分支推送了他的提交，而碰巧你也对同样的文件做了修改，并试图推送。结果推送失败，因为你的小伙伴和你试图推送的提交有冲突，解决办法也很简单，<code>Git</code>已经提示我们，先用<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下了，然后，在本地合并，解决冲突，再推送：</p><pre class="language-YAML"><code class="language-YAML">git add env.txt//你提交修改内容到本地仓库，并试图推送到远端
git commit -m "add new env"
git push origin dev//出现冲突，需要在本地合并，解决冲突后推送
</code></pre><p><code>git pull</code>也失败了，因为没有指定本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接，根据提示，设置<code>dev</code>和<code>origin/dev</code>的链接。再<code>pull</code>，这回<code>git pull</code>成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，在<code>push</code>。</p><pre class="language-YAML"><code class="language-YAML">git branch --set-upstream-to=origin/dev dev//本地dev分支与远程origin/dev分支链接
git pull//pull成功，但合并有冲突

git add env.txt//解决冲突
git commit -m "fix env conflict"//添加到本地版本库
git push origin dev//推送到远端
</code></pre><p>因此，<strong>多人协作的工作模式通常是这样的</strong>：</p><ul><li>1.首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</li><li>2.如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li><li>3.如果合并有冲突，则解决冲突，并在本地提交；</li><li>4.没有冲突或者解决到冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</li></ul><p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p><p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p><h3 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h3><p>上一节我们看到了，多人在同一个分支协作时，很容易出现冲突。即使没有冲突，后<code>push</code>的同学不得不先<code>pull</code>，在本地合并，然后才能<code>push</code>成功。每次合并再<code>push</code>后，分支变成了很复杂。</p><p>总之，看上去很乱，有些强迫症的同学会问：为什么<code>Git</code>的提交历史不能是一条干净的直线？</p><p>其实是可以做到的！<code>Git</code>有一种成为<code>rebase</code>的操作，有人把它翻译成“变基”。</p><p>我们从实际问题出发，看看怎么把分叉的提交变成了直线。</p><p>在和远程分支同步后，我们对<code>hello.py</code>这个文件做了两次提交。用<code>git log</code>命令查看。</p><pre class="language-YAML"><code class="language-YAML">git log --graph --pretty=oneline --abbrev-commit
</code></pre><p>注意到<code>Git</code>用<code>（HEAD-&gt;master）</code>和<code>（origin/master）</code>标识当前分支的<code>HEAD</code>和远程<code>origin</code>的位置分别是<code>582d922 add author</code>和<code>d1be385 init hello</code>，本地分支比远程分支快两个提交。</p><p>现在我们尝试推送本地分支，失败了，这说明有人先与我们推送了远程分支。按照经验，先<code>pull</code>一下，再用<code>git status</code>查看状态，加上刚才合并的提交，现在我们本地分支比远程分支超前<code>3</code>个提交。用<code>git log</code>查看。</p><pre class="language-YAML"><code class="language-YAML">git push origin master//推送到远程失败
git pull//解决冲突再推送

git push origin master//再次推送，查看状态和提交
git status
git log --graph --pretty=oneline --abbrev-commit
</code></pre><p>对于强迫症同学来说，<strong>现在事情有点不对头，本地的提交历史分叉了</strong>。如果现在把本地分支<code>push</code>到远程，有没有问题？</p><p>有！</p><p>什么问题？</p><p><strong>不好看！</strong></p><p>有没有解决办法？</p><p>有！</p><p>这个时候，**<code>rebase</code>就派上了用场**。我们输入命令<code>git rebase</code>试试：</p><pre class="language-YAML"><code class="language-YAML">git rebase
</code></pre><p>输出了一大堆操作，到底是啥效果？用<code>git log</code>看看：</p><pre class="language-YAML"><code class="language-YAML">git log --graph --pretty=oneline --abbrev-commit
</code></pre><p><strong>原本分叉的提交现在变成一条直线了</strong>！这种神奇的操作是怎么实现的？其实原理非常简单。我们注意观察，发现Git把我们本地的提交“挪动”了位置，放到了<code>f005ed4 (origin/master) set exit=1</code>之后，这样，整个提交历史就成了一条直线。rebase操作前后，最终的提交内容是一致的，但是，我们本地的commit修改内容已经变化了，它们的修改不再基于<code>d1be385 init hello</code>，而是基于<code>f005ed4 (origin/master) set exit=1</code>，但最后的提交<code>7e61ed4</code>内容是一致的。</p><p><strong>这就是<code>rebase</code>操作的特点</strong>：把分叉的提交历史“整理”成一条直线，看上去更直观。<strong>缺点</strong>是本地的分叉提交已经被修改过了。</p><p><strong>最后，通过<code>push</code>操作把本地分支推送到远程。再用git log看看效果</strong>：远程分支的提交历史也是一条直线。</p><pre class="language-YAML"><code class="language-YAML">git log --graph --pretty=oneline --abbrev-commit
</code></pre><h2 id="5-标签管理"><a href="#5-标签管理" class="headerlink" title="5.标签管理"></a>5.标签管理</h2><p>发布一个版本是，我们通常现在版本库中打一个标签(<code>tag</code>)，这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p><p><strong><code>Git</code>的标签虽然是版本库的快照，但其实它就是指向某个<code>commit</code>的指针</strong>（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p><p><code>Git</code>有<code>commit</code>，为什么还要引入<code>tag</code>？</p><p>“请把上周一的那个版本打包发布，<code>commit</code>号是<code>6a5819e...</code>”</p><p>“一串乱七八糟的数字不好找！”</p><p>如果换一种方法：</p><p>“请把上周一的那个版本打包发布，版本号是<code>v1.2</code>”</p><p>“好的，按照<code>tag v1.2</code>查找<code>commit</code>就行！”</p><p>所以，<code>tag</code>就是一个让人容易记住的有意义的名字，它跟某个<code>commit</code>绑定在一起。</p><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p><code>Git</code>打标签非常简单。首先<strong>切换到要打标签的分支上，然后敲命令</strong><code>git tag &lt;name&gt;</code>就可以打一个新标签，<strong>默认标签是打在最新提交的</strong><code>commit</code>上的。</p><pre class="language-YAML"><code class="language-YAML">git switch dev//切换分支
git tag v1.0//给当前分支的最新提交打标签
git tag//查看标签
</code></pre><p>有时候，如果忘记了打标签，比如<strong>要找到上周一的提交打标签</strong>，怎么办？方法是找到历史提交的<code>commit id</code>，然后打上就可以了。</p><pre class="language-YAML"><code class="language-YAML">git log --pretty=oneline --abbrev-commit//查看历史提交
git tag v0.9 f52c633//给历史提交commit id打标签
git tag//查看标签
</code></pre><p>注意：标签不是按时间顺序列出，而是按照字母排序的。可以用<code>git show &lt;tagname&gt;</code>查看标签信息</p><pre class="language-YAML"><code class="language-YAML">git show v0.9//查看标签信息，v0.9打在哪个提交上
</code></pre><p><strong>还可以创建带有说明的标签</strong>，用<code>-a</code>指定签名，<code>-m</code>指定说明文字</p><pre class="language-YAML"><code class="language-YAML">git tag -a v0.1 -m "version 0.1 released" 1094adb //创建带签名和说明的标签
git show v0.1
</code></pre><p><strong>注意</strong>：<strong>标签总是和某个<code>commit</code>挂钩</strong>。如果这个<code>commit</code>既出现在<code>master</code>分支，又出现在<code>dev</code>分支，那么在这两个分支上都可以看到这个标签。</p><h3 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h3><p>如果<strong>标签打错了，也可以删除</strong>。因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p><pre class="language-YAML"><code class="language-YAML">git tag -d v1.0//删除标签
</code></pre><p>如果要<strong>推送某个标签到远程</strong>，使用命令<code>git push origin &lt;tagname&gt;</code>，或者一次性推送全部为推送到远程的本地标签<code>git push origin --tags</code></p><pre class="language-YAML"><code class="language-YAML">git push origin v1.0//推送标签v1.0到远程
git push origin --tags//推送所有未推送到远程的标签
</code></pre><p>如果<strong>标签已经推送到远程，要删除远程标签就麻烦一点</strong>，先从本地删除，然后，从远程删除，命令也是<code>push</code>，但格式如下。要看是否真的从远程库删除了标签，可以登录<code>Github</code>查看</p><pre class="language-yaml"><code class="language-yaml">git tag <span class="token punctuation">-</span>d v0.9//删除本地标签v0.9
git push origin <span class="token punctuation">:</span>refs/tags/v0.9 //删除远程标签
</code></pre><h2 id="6-使用Github"><a href="#6-使用Github" class="headerlink" title="6.使用Github"></a>6.使用Github</h2><p><code>Github</code>是免费的远程仓库，开源协作社区。通过<code>Github</code>，既可以让别人参与你的开源项目，也可以参与别人的开源项目。</p><p>在<code>GitHub</code>出现以前，开源项目开源容易，但让广大人民群众参与进来比较困难，因为要参与，就要提交代码，而给每个想提交代码的群众都开一个账号那是不现实的，因此，群众也仅限于报个<code>bug</code>，即使能改掉<code>bug</code>，也只能把<code>diff</code>文件用邮件发过去，很不方便。</p><p>但是在<code>GitHub</code>上，利用<code>Git</code>极其强大的克隆和分支功能，广大人民群众真正可以第一次自由参与各种开源项目了。</p><p><strong>如何参与一个开源项目呢？</strong>比如人气极高的<code>bootstrap</code>项目，这是一个非常强大的<code>CSS</code>框架，你可以访问它的项目主页<a target="_blank" rel="noopener" href="https://github.com/twbs/bootstrap%EF%BC%8C%E7%82%B9%E2%80%9C%60Fork%60%E2%80%9D%E5%B0%B1%E5%9C%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E8%B4%A6%E5%8F%B7%E4%B8%8B%E5%85%8B%E9%9A%86%E4%BA%86%E4%B8%80%E4%B8%AA%60bootstrap%60%E4%BB%93%E5%BA%93%EF%BC%8C%E7%84%B6%E5%90%8E%EF%BC%8C%E4%BB%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E8%B4%A6%E5%8F%B7%E4%B8%8B%60clone%60">https://github.com/twbs/bootstrap，点“`Fork`”就在自己的账号下克隆了一个`bootstrap`仓库，然后，从自己的账号下`clone`</a></p><pre class="language-yaml"><code class="language-yaml">git clone git@github.com<span class="token punctuation">:</span>wangxinzhi0/bootstrap.git//从自己仓库克隆
</code></pre><p><strong>一定要从自己的账号下<code>clone</code>仓库，这样你才能推送修改。</strong>如果从<code>bootstrap</code>的作者的仓库地址<code>git@github.com:twbs/bootstrap.git</code>克隆，因为没有权限，你将不能推送修改。</p><p><code>Bootstrap</code>的官方仓库<code>twbs/bootstrap</code>、你在<code>GitHub</code>上克隆的仓库<code>my/bootstrap</code>，以及你自己克隆到本地电脑的仓库，他们的关系就像下图显示的那样</p><p><img src="https://cdn.jsdelivr.net/gh/wangxinzhi0/PicX-image@master/Git/9.3340mvfh33u0.png" alt="9"></p><p><strong>如果你想修复<code>bootstrap</code>的一个<code>bug</code>，或者新增一个功能</strong>，立刻就可以开始干活，干完后，<strong>往自己的仓库推送</strong>。</p><p><strong>如果你希望<code>bootstrap</code>的官方库能接受你的修改</strong>，你就可以在<code>GitHub</code>上发起一个<code>pull request</code>。当然，对方是否接受你的<code>pull request</code>就不一定了。</p><h2 id="7-使用Gitee"><a href="#7-使用Gitee" class="headerlink" title="7.使用Gitee"></a>7.使用Gitee</h2><p>使用<code>GitHub</code>时，国内的用户经常遇到的问题是访问速度太慢，有时候还会出现无法连接的情况（原因你懂的）。</p><p>如果我们希望体验<code>Git</code>飞一般的速度，可以使用国内的<code>Git</code>托管服务——<a target="_blank" rel="noopener" href="https://gitee.com/">Gitee</a>。</p><p>和<code>GitHub</code>相比，<code>Gitee</code>也提供免费的<code>Git</code>仓库。此外，还集成了代码质量检测、项目演示等功能。对于团队协作开发，<code>Gitee</code>还提供了项目管理、代码托管、文档管理的服务，<code>5</code>人以下小团队免费。</p><p><strong>使用<code>Gitee</code>和使用<code>GitHub</code>类似</strong>，我们在<code>Gitee</code>上注册账号并登录后，需要先上传自己的<code>SSH</code>公钥。选择右上角用户头像<code>-&gt;</code>菜单“修改资料”，然后选择“<code>SSH</code>公钥”，填写一个便于识别的标题，然后把用户主目录下的<code>.ssh/id_rsa.pub</code>文件的内容粘贴进去，点击“确定”即可完成并看到刚才添加的<code>Key</code>。</p><p>如果我们已经有了一个本地的<code>git</code>仓库（例如，一个名为learngit的本地库），如何把它<strong>关联到<code>Gitee</code>的远程库上呢</strong>？</p><p>首先，我们在<code>Gitee</code>上创建一个新的项目，选择右上角用户头像<code>-&gt;</code>菜单“控制面板”，然后点击“创建项目”，项目名称最好与本地库保持一致，然后，我们在本地库上使用命令<code>git remote add</code>把它和<code>Gitee</code>的远程库关联。</p><pre class="language-yaml"><code class="language-yaml">git remote add origin git@gitee.com<span class="token punctuation">:</span>wangxinzhi0/learngit.git//本地仓库和码云关联
</code></pre><p>之后就可以正常使用<code>git push</code>和<code>git pull</code>推送了！</p><p>如果在使用命令<code>git remote add</code>时报错<code>fatal: remote origin already exists</code>，说明本地库已经关联了一个名叫<code>origin</code>的远程库，此时，可以用<code>git remote -v</code>查看远程库信息，删除已有的<code>Github</code>远程库，再关联<code>Gitee</code>的远程库。</p><pre class="language-YAML"><code class="language-YAML">git remote -v//查看远程库
git remote rm origin//删除Github远程库
git remote add origin git@gitee.com:wangxinzhi0/learngit.git//本地仓库和码云关联
git remote -v
</code></pre><p><strong>有的小伙伴又要问了，一个本地库能不能既关联GitHub，又关联Gitee呢？</strong></p><p>答案是肯定的，因为<code>git</code>本身是分布式版本控制系统，可以同步到另外一个远程库，当然也可以同步到另外两个远程库。</p><p>使用多个远程库时，我们要注意，<code>git</code>给远程库起的默认名称是<code>origin</code>，如果有多个远程库，我们<strong>需要用不同的名称来标识不同的远程库</strong>。</p><p>仍然以<code>learngit</code>本地库为例，我们先删除已关联的名为<code>origin</code>的远程库：</p><pre class="language-YAML"><code class="language-YAML">git remote rm origin//删除现有关联库origin
git remote add github git@github.com:wangxinzhi0/learngit.git //关联github，注意远程库名字
git remote add gitee git@gitee.com:wangxinzhi0/learngit.git //关联gitee，注意远程库名字
git remote -v //有两个远程库信息
    
git push github master//推送到github
git push gitee master//推送到gitee
</code></pre><p>这样，本地库就同时与多个远程库互相同步，<code>Gitee</code>也同样提供了<code>Pull request</code>功能，可以让其他小伙伴参与到开源项目中来</p><p><img src="https://cdn.jsdelivr.net/gh/wangxinzhi0/PicX-image@master/Git/10.3izp6r7ob5a0.png" alt="10"></p><h2 id="8-自定义Git"><a href="#8-自定义Git" class="headerlink" title="8.自定义Git"></a>8.自定义Git</h2><p>在安装<code>Git</code>时，我们已经配置了<code>user.name</code>和<code>user.email</code>，实际上，<code>Git</code>还有很多可配置项。</p><p>比如，让<code>Git</code>显示颜色，会让命令输出看起来更醒目。这样，<code>Git</code>会适当显示不同的颜色，比如<code>git status</code>命令，文件名就会标上颜色。</p><pre class="language-YAML"><code class="language-YAML">git config --global color.ui true //让Git显示颜色
git status
</code></pre><h3 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h3><p>有些时候，你必须把某些文件放到<code>Git</code>工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件等等。每次<code>git status</code>都会显示<code>Untracked files...</code>，有些强迫症的同学心里肯定不爽。</p><p>好在<code>Git</code>考虑到了大家的感受，这个问题解决起来也很简单，<strong>在<code>Git</code>工作区的根目录下创建一个特殊的<code>.gitignore</code>文件</strong>，然后把要忽略的文件名填进去，<code>Git</code>就会自动忽略这些文件。</p><p>不需要从头写<code>.gitignore</code>文件，<code>GitHub</code>已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：<a target="_blank" rel="noopener" href="https://github.com/github/gitignore">https://github.com/github/gitignore</a></p><p><strong>忽略文件的原则是</strong>：</p><ul><li>忽略操作系统自动生成的文件，比如缩略图等；</li><li>忽略变异生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没有比较放进版本库，比如Java编译产生的.class文件；</li><li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</li></ul><p>举个例子：</p><p>假设你在<code>Windows</code>下进行<code>Python</code>开发，<code>Windowns</code>会自动在有图片的目录下生成隐藏的缩略图文件，如果有自定义目录，目录下就会有<code>Desktop.ini</code>文件，因此你需要忽略<code>Windows</code>自动生成的垃圾文件</p><pre class="language-java"><code class="language-java"># Windows<span class="token operator">:</span>
Thumbs<span class="token punctuation">.</span>db
ehthumbs<span class="token punctuation">.</span>db
Desktop<span class="token punctuation">.</span>ini
</code></pre><p>然后，继续忽略<code>Python</code>编译产生的<code>.pyc</code>、<code>.pyo</code>、<code>dist</code>等文件或目录：</p><pre class="language-java"><code class="language-java"># Python<span class="token operator">:</span>
<span class="token operator">*</span><span class="token punctuation">.</span>py<span class="token punctuation">[</span>cod<span class="token punctuation">]</span>
<span class="token operator">*</span><span class="token punctuation">.</span>so
<span class="token operator">*</span><span class="token punctuation">.</span>egg
<span class="token operator">*</span><span class="token punctuation">.</span>egg<span class="token operator">-</span>info
dist
build
</code></pre><p>加上你自己定义的文件，最终得到一个完整的<code>.gitignore</code>文件，内容如下</p><pre class="language-java"><code class="language-java"># Windows<span class="token operator">:</span>
Thumbs<span class="token punctuation">.</span>db
ehthumbs<span class="token punctuation">.</span>db
Desktop<span class="token punctuation">.</span>ini

# Python<span class="token operator">:</span>
<span class="token operator">*</span><span class="token punctuation">.</span>py<span class="token punctuation">[</span>cod<span class="token punctuation">]</span>
<span class="token operator">*</span><span class="token punctuation">.</span>so
<span class="token operator">*</span><span class="token punctuation">.</span>egg
<span class="token operator">*</span><span class="token punctuation">.</span>egg<span class="token operator">-</span>info
dist
build

# My configurations<span class="token operator">:</span>
db<span class="token punctuation">.</span>ini
deploy_key_rsa
</code></pre><p>最后一步就是把<code>.gitignore</code>也提交到Git，就完成了！**当然检验<code>.gitignore</code>的标准是<code>git status</code>命令是不是说<code>working directory clean</code>**。</p><p><strong>使用Windows的童鞋注意了，如果你在资源管理器里新建一个<code>.gitignore</code>文件，它会非常弱智地提示你必须输入文件名</strong>，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为<code>.gitignore</code>了。</p><p>有些时候，<strong>你想添加一个文件到<code>Git</code>，但发现添加不了，原因是这个文件被<code>.gitignore</code>忽略了</strong>，如果你确实想添加该文件，可以用<code>-f</code>强制添加到<code>Git</code></p><pre class="language-YAML"><code class="language-YAML">git add -f App.class//强制添加忽略文件到Git
</code></pre><p>或者你发现，<strong>可能是<code>.gitignore</code>写得有问题，需要找出来到底哪个规则写错了</strong>，可以用<code>git check-ignore</code>命令检查，Git会告诉我们，<code>.gitignore</code>的第3行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。</p><pre class="language-YAML"><code class="language-YAML">git check-ignore -v App.class//找出App.class的忽略规则
</code></pre><p>还有些时候，当我们编写了规则排除了部分文件时，发现<code>.*</code>这个规则把<code>.gitignore</code>也排除了，并且<code>App.class</code>需要被添加到版本库，但是被<code>*.class</code>规则排除了。</p><pre class="language-YAML"><code class="language-YAML"># 排除所有.开头的隐藏文件:
.*
# 排除所有.class文件:
*.class
</code></pre><p>虽然可以用<code>git add -f</code>强制添加进去，但有强迫症的童鞋还是希望不要破坏<code>.gitignore</code>规则，这个时候，可以添加两条例外规则。<strong>把指定文件排除在<code>.gitignore</code>规则外的写法就是<code>!</code>+文件名</strong>，所以，只需把例外文件添加进去即可。</p><pre class="language-YAML"><code class="language-YAML"># 排除所有.开头的隐藏文件:
.*
# 排除所有.class文件:
*.class

# 不排除.gitignore和App.class:
!.gitignore
!App.class
</code></pre><h3 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h3><p>有没有经常敲错命令？比如<code>git status</code>？<code>status</code>这个单词真心不好记。</p><p>如果敲<code>git st</code>就表示<code>git status</code>那就简单多了，当然这种偷懒的办法我们是极力赞成的。</p><p>我们只需要敲一行命令，告诉<code>Git</code>，以后<code>st</code>就表示<code>status</code></p><pre class="language-YAML"><code class="language-YAML">git config --global alias.st status//设置status别名为st
git st
</code></pre><p>当然还有别的命令也可以简写，很多人用<code>co</code>表示<code>checkout</code>，<code>ci</code>表示<code>commit</code>，<code>br</code>表示<code>branch</code></p><pre class="language-YAML"><code class="language-YAML">git config --global alias.co checkout
git config --global alias.ci commit
git config --global alias.br branch
</code></pre><p>以后提交就可以简写成</p><pre class="language-YAML"><code class="language-YAML">git ci -m "bala bala..."
</code></pre><p><strong><code>--global</code>参数是全局参数</strong>，也就是这些命令在这台电脑的所有<code>Git</code>仓库下都有用。</p><p>在<strong>撤销修改</strong>一节中，我们知道，命令<code>git reset HEAD file</code>可以把<strong>暂存区的修改撤销掉</strong>（<code>unstage</code>），重新放回工作区。既然是一个<code>unstage</code>操作，就可以配置一个<code>unstage</code>别名</p><pre class="language-YAML"><code class="language-YAML">git config --global alias.unstage 'reset HEAD'
git unstage test.py//实际执行git reset HEAD test.py
</code></pre><p><strong>配置一个<code>git last</code>，让其显示最后一次提交信息</strong></p><pre class="language-YAML"><code class="language-YAML">git config --global alias.last 'log -1'
git last//显示最后一次提交信息
</code></pre><p>甚至还有人丧心病狂地把<code>lg</code>配置成了</p><pre class="language-YAML"><code class="language-YAML">git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit"
</code></pre><p>在<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/896043488029600/897889638509536">撤销修改</a>一节中，我们知道，命令<code>git reset HEAD file</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个unstage操作，就可以配置一个<code>unstage</code>别名：</p><pre class="language-YAML"><code class="language-YAML">$ git config --global alias.unstage 'reset HEAD'
</code></pre><p>当你敲入命令：</p><pre class="language-YAML"><code class="language-YAML">$ git unstage test.py
</code></pre><p>实际上Git执行的是：</p><pre class="language-YAML"><code class="language-YAML">$ git reset HEAD test.py
</code></pre><p>配置一个<code>git last</code>，让其显示最后一次提交信息：</p><pre class="language-YAML"><code class="language-YAML">$ git config --global alias.last 'log -1'
</code></pre><p>这样，用<code>git last</code>就能显示最近一次的提交：</p><pre class="language-YAML"><code class="language-YAML">$ git last
commit adca45d317e6d8a4b23f9811c3d7b7f0f180bfe2
Merge: bd6ae48 291bea8
Author: Michael Liao <askxuefeng @gmail.com>
Date:   Thu Aug 22 22:49:22 2013 +0800

    merge & fix hello.py
</askxuefeng></code></pre><p>甚至还有人丧心病狂地把<code>lg</code>配置成了：</p><pre class="language-YAML"><code class="language-YAML">git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit"
</code></pre><p>来看看<code>git lg</code>的效果：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919059728302912/0" alt="git-lg"></p><p>为什么不早点告诉我？别激动，咱不是为了多记几个英文单词嘛！</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>配置Git的时候，加上<code>--global</code>是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。</p><p>配置文件放哪了？每个仓库的Git配置文件都放在<code>.git/config</code>文件中：</p><pre class="language-YAML"><code class="language-YAML">$ cat .git/config 
[core]
    repositoryformatversion = 0
    filemode = true
    bare = false
    logallrefupdates = true
    ignorecase = true
    precomposeunicode = true
[remote "origin"]
    url = git@github.com:michaelliao/learngit.git
    fetch = +refs/heads/*:refs/remotes/origin/*
[branch "master"]
    remote = origin
    merge = refs/heads/master
[alias]
    last = log -1
</code></pre><p><strong>每个仓库别名就在<code>[alias]</code>后面，要删除别名，直接把对应的行删掉即可</strong>。</p><p><strong>而当前用户的<code>Git</code>配置文件放在用户主目录下的一个隐藏文件<code>.gitconfig</code>中</strong></p><p>配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。</p><pre class="language-YAML"><code class="language-YAML">$ cat .gitconfig
[alias]
    co = checkout
    ci = commit
    br = branch
    st = status
[user]
    name = Your Name
    email = your@email.com
</code></pre><h3 id="搭建Git服务器"><a href="#搭建Git服务器" class="headerlink" title="搭建Git服务器"></a>搭建Git服务器</h3><p>在<strong>远程仓库</strong>一节中，我们讲了远程仓库实际上和本地仓库没啥不同，纯粹为了<code>7x24</code>小时开机并交换大家的修改。</p><p><code>GitHub</code>就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给<code>GitHub</code>交保护费，那就只能自己搭建一台<code>Git</code>服务器作为私有仓库使用。</p><p>搭建<code>Git</code>服务器需要准备一台运行<code>Linux</code>的机器，强烈推荐用<code>Ubuntu</code>或<code>Debian</code>，这样，通过几条简单的<code>apt</code>命令就可以完成安装。</p><p>假设你已经有<code>sudo</code>权限的用户账号，下面，<strong>正式开始安装</strong>。</p><p>第一步，安装<code>git</code>：</p><pre class="language-YAML"><code class="language-YAML">$ sudo apt-get install git
</code></pre><p>第二步，创建一个<code>git</code>用户，用来运行<code>git</code>服务：</p><pre class="language-YAML"><code class="language-YAML">$ sudo adduser git
</code></pre><p>第三步，创建证书登录：</p><p>收集所有需要登录的用户的公钥，就是他们自己的<code>id_rsa.pub</code>文件，把所有公钥导入到<code>/home/git/.ssh/authorized_keys</code>文件里，一行一个。</p><p>第四步，初始化Git仓库：</p><p>先选定一个目录作为Git仓库，假定是<code>/srv/sample.git</code>，在<code>/srv</code>目录下输入命令：</p><pre class="language-YAML"><code class="language-YAML">$ sudo git init --bare sample.git
</code></pre><p>Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以<code>.git</code>结尾。然后，把owner改为<code>git</code>：</p><pre class="language-YAML"><code class="language-YAML">$ sudo chown -R git:git sample.git
</code></pre><p>第五步，禁用shell登录：</p><p>出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑<code>/etc/passwd</code>文件完成。找到类似下面的一行：</p><pre class="language-YAML"><code class="language-YAML">git:x:1001:1001:,,,:/home/git:/bin/bash
</code></pre><p>改为：</p><pre class="language-YAML"><code class="language-YAML">git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell
</code></pre><p>这样，<code>git</code>用户可以正常通过ssh使用git，但无法登录shell，因为我们为<code>git</code>用户指定的<code>git-shell</code>每次一登录就自动退出。</p><p>第六步，克隆远程仓库：</p><p>现在，可以通过<code>git clone</code>命令克隆远程仓库了，在各自的电脑上运行：</p><pre><code>$ git clone git@server:/srv/sample.git
Cloning into &#39;sample&#39;...
warning: You appear to have cloned an empty repository.
</code></pre><p>剩下的推送就简单了。</p><p><strong>管理公钥</strong></p><p>如果团队很小，把每个人的公钥收集起来放到服务器的<code>/home/git/.ssh/authorized_keys</code>文件里就是可行的。如果团队有几百号人，就没法这么玩了，这时，可以用<a target="_blank" rel="noopener" href="https://github.com/res0nat0r/gitosis">Gitosis</a>来管理公钥。</p><p>这里我们不介绍怎么玩<a target="_blank" rel="noopener" href="https://github.com/res0nat0r/gitosis">Gitosis</a>了，几百号人的团队基本都在500强了，相信找个高水平的<code>Linux</code>管理员问题不大。</p><p><strong>管理权限</strong></p><p>有很多不但视源代码如生命，而且视员工为窃贼的公司，会在版本控制系统里设置一套完善的权限控制，每个人是否有读写权限会精确到每个分支甚至每个目录下。因为Git是为Linux源代码托管而开发的，所以Git也继承了开源社区的精神，不支持权限控制。不过，因为Git支持钩子（hook），所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制的目的。<a target="_blank" rel="noopener" href="https://github.com/sitaramc/gitolite">Gitolite</a>就是这个工具。</p><p>这里我们也不介绍<a target="_blank" rel="noopener" href="https://github.com/sitaramc/gitolite">Gitolite</a>了，不要把有限的生命浪费到权限斗争中。</p><h2 id="9-使用Source-Tree"><a href="#9-使用Source-Tree" class="headerlink" title="9.使用Source Tree"></a>9.使用Source Tree</h2><p>当我们对Git的提交、分支已经非常熟悉，可以熟练使用命令操作Git后，再使用GUI工具，就可以更高效。</p><p>Git有很多图形界面工具，这里我们推荐<a target="_blank" rel="noopener" href="https://www.sourcetreeapp.com/">SourceTree</a>，它是由<a target="_blank" rel="noopener" href="https://www.atlassian.com/">Atlassian</a>开发的免费Git图形界面工具，可以操作任何Git库。</p><p>首先从<a target="_blank" rel="noopener" href="https://www.sourcetreeapp.com/">官网</a>下载SourceTree并安装，然后直接运行SourceTree。</p><p>第一次运行SourceTree时，SourceTree并不知道我们的Git库在哪。如果本地已经有了Git库，直接从资源管理器把文件夹拖拽到SourceTree上，就添加了一个本地Git库。</p><p>也可以选择“New”-“Clone from URL”直接从远程克隆到本地。</p><p><strong>提交</strong></p><p>我们双击<code>learngit</code>这个本地库，SourceTree会打开另一个窗口，展示这个Git库的当前所有分支以及文件状态。选择左侧面板的“WORKSPACE”-“File status”，右侧会列出当前已修改的文件（Unstaged files）</p><p>选中某个文件，该文件就自动添加到“Staged files”，实际上是执行了<code>git add README.md</code>命令</p><p>然后，我们在下方输入Commit描述，点击“Commit”，就完成了一个本地提交</p><p>实际上是执行了<code>git commit -m &quot;update README.md&quot;</code>命令。</p><p><strong>分支</strong></p><p>在左侧面板的“BRANCHES”下，列出了当前本地库的所有分支。当前分支会加粗并用○标记。要切换分支，我们只需要选择该分支，例如<code>master</code>，然后点击右键，在弹出菜单中选择“Checkout master”，实际上是执行命令<code>git checkout master</code>：</p><p>要合并分支，同样选择待合并分支，例如<code>dev</code>，然后点击右键，在弹出菜单中选择“Merge dev into master”，实际上是执行命令<code>git merge dev</code></p><p><strong>推送</strong></p><p>在SourceTree的工具栏上，分别有<code>Pull</code>和<code>Push</code>，分别对应命令<code>git pull</code>和<code>git push</code>，只需注意本地和远程分支的名称要对应起来，使用时十分简单。</p><p>注意到使用SourceTree时，我们只是省下了敲命令的麻烦，SourceTree本身还是通过Git命令来执行任何操作。如果操作失败，SourceTree会自动显示执行的Git命令以及错误信息，我们可以通过Git返回的错误信息知道出错的原因。</p><h2 id="10-总结"><a href="#10-总结" class="headerlink" title="10.总结"></a>10.总结</h2><p>Git虽然极其强大，命令繁多，但常用的就那么十来个，掌握好这十几个常用命令，你已经可以得心应手地使用Git了。<a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2">Git中文手册</a></p><p><a target="_blank" rel="noopener" href="https://liaoxuefeng.gitee.io/resource.liaoxuefeng.com/git/git-cheat-sheet.pdf">Git命令表</a>：</p><table><thead><tr><th>GIT BASICS</th><th>GIT基础命令</th></tr></thead><tbody><tr><td>git init <code>&lt;directory&gt;</code></td><td>在指定目录下创建一个空的git repo，不带参数在当前目录下创建一个git repo</td></tr><tr><td>git clone <code>&lt;repo&gt;</code></td><td>克隆一个指定的repo到本地。指定的repo可以是本地文件系统或者由HTTP或SSH指定的远程路径</td></tr><tr><td>git config user.name <code>&lt;name&gt;</code></td><td>针对当前repo配置用户名。使用–global参数将配置全局用户名</td></tr><tr><td>git add <code>&lt;directory&gt;</code></td><td>将指定目录的所有修改加入到暂存区。把<code>&lt;directory&gt;</code>替换成<code>&lt;file&gt;</code>将添加指定文件的修改到暂存区</td></tr><tr><td>git commit -m “<code>&lt;message&gt;</code>“</td><td>提交暂存区的修改，使用指定的<code>&lt;message&gt;</code>最为提交信息</td></tr><tr><td>git status</td><td>显示哪些文件已被staged、未被staged以及未跟踪(untracked)</td></tr><tr><td>git log</td><td>以缺省格式显示全部的commit历史</td></tr><tr><td><strong>GIT DIFF</strong></td><td><strong>GIT差异比较命令</strong></td></tr><tr><td>git diff</td><td>比较工作区和暂存区的修改</td></tr><tr><td>git diff HEAD</td><td>比较工作区和上一次commit后的修改</td></tr><tr><td>git diff –cached</td><td>比较暂存区和上一次commit后的修改</td></tr><tr><td><strong>UNDOING CHANGES</strong></td><td><strong>撤销修改命令</strong></td></tr><tr><td>git revert <code>&lt;commit&gt;</code></td><td>对指定<code>&lt;commit&gt;</code>创建一个undo的<code>&lt;commit&gt;</code>，并应用到当前分支</td></tr><tr><td>git reset <code>&lt;file&gt;</code></td><td>将<code>&lt;file&gt;</code>从暂存区移除，但保持工作区不变。此操作不会修改工作区的任何文件</td></tr><tr><td><strong>REWRITING GIT HISTORY</strong></td><td><strong>重写GIT提交命令</strong></td></tr><tr><td>git commit -m <code>&lt;message&gt;</code> –amend</td><td>将当前staged修改合并到最近一次的commit中</td></tr><tr><td>git rebase <code>&lt;base&gt;</code></td><td>基于<code>&lt;base&gt;</code>对当前分支进行rebase。<code>&lt;base&gt;</code>可以是commit、分支名称、tag或相对于HEAD的commit</td></tr><tr><td>git reflog</td><td>显示本地repo的所有commit日志</td></tr><tr><td><strong>GIT BRANCHES</strong></td><td><strong>GIT分支命令</strong></td></tr><tr><td>git branch</td><td>显示本地repo的所有分支</td></tr><tr><td>git switch -c <code>&lt;branch&gt;</code></td><td>创建并切换到一个新的分支<code>&lt;branch&gt;</code>，去掉-c参数将切换到一个已有分支<code>&lt;branch&gt;</code></td></tr><tr><td>REMOTE REPOSITORIES</td><td><strong>远程库操作命令</strong></td></tr><tr><td>git remote add <code>&lt;name&gt;</code> <code>&lt;url&gt;</code></td><td>添加一个新的远程连接。添加后可使用<code>&lt;name&gt;</code>作为指定<code>&lt;url&gt;</code>远程连接的名称</td></tr><tr><td>git fetch <code>&lt;remote&gt;</code> <code>&lt;branch&gt;</code></td><td>从指定<code>&lt;remote&gt;</code>抓取指定<code>&lt;branch&gt;</code>的所有commit到本地repo。去掉<code>&lt;branch&gt;</code>将抓取远程所有分支的修改。</td></tr><tr><td>git pull <code>&lt;remote&gt;</code></td><td>从指定<code>&lt;remote&gt;</code>抓取所有分支的commit并立即合并到本地repo</td></tr><tr><td>git push <code>&lt;remote&gt;</code> <code>&lt;branch&gt;</code></td><td>将本地指定<code>&lt;branch&gt;</code>推送到指定远程<code>&lt;remote&gt;</code>。如果远程没有对应的分支，将自动在远程创建此分支。</td></tr><tr><td><strong>GIT CONFIG</strong></td><td><strong>GIT配置命令</strong></td></tr><tr><td>git config –global user.name <code>&lt;name&gt;</code></td><td>配置当前用户名，使用–global参数将针对当前系统登录用户生效</td></tr><tr><td>git config –global user.name <code>&lt;email&gt;</code></td><td>配置当前用户Email</td></tr><tr><td>git config –global alias.<code>&lt;alias-name&gt;</code> <code>&lt;git-command&gt;</code></td><td>配置一个git命令的快捷方式。例如：配 置<code>alias.glog log --graph --oneline</code>使<code>git glog</code>相当于<code>git log --graph --oneline</code></td></tr><tr><td>git config –system core.editor <code>&lt;editor&gt;</code></td><td>配置文本编辑器，例如vi，在必要时自动打开此文本编辑器</td></tr><tr><td>git config –global –edit</td><td>打开当前用户的git全局配置并编辑</td></tr><tr><td><strong>GIT LOG</strong></td><td><strong>GIT日志命令</strong></td></tr><tr><td>git log <code>-&lt;limit&gt;</code></td><td>限制log的显示数量。例如：git log -5仅显示最新5条commit</td></tr><tr><td>git log –oneline</td><td>每行显示一条commit</td></tr><tr><td>git log –author=”<code>&lt;pattern&gt;</code>“</td><td>按提交者名字搜索并显示commit</td></tr><tr><td>git log –grep=”<code>&lt;pattern&gt;</code>“</td><td>按指定内容搜索并显示commit</td></tr><tr><td>git log <code>&lt;since&gt;</code>..<code>&lt;until&gt;</code></td><td>显示指定范围的commit。范围参数可以是commit ID、分支名称、HEAD或任意相对位置</td></tr><tr><td>git log –<code>&lt;file&gt;</code></td><td>仅显示包含指定文件修改的commit</td></tr><tr><td>git log –graph</td><td>使用–graph参数显示图形化的branch信息</td></tr><tr><td><strong>GIT RESET</strong></td><td><strong>版本回退命令</strong></td></tr><tr><td>git reset</td><td>移除所有暂存区的修改，但不会修改工作区</td></tr><tr><td>git reset <strong>–hard</strong></td><td>移除所有暂存区的修改，并强制删除所有工作区的修改</td></tr><tr><td>git reset <code>&lt;commit&gt;</code></td><td>将当前分支回滚到指定<code>&lt;commit&gt;</code>，清除暂存区的修改，但保持工作区状态不变</td></tr><tr><td>git reset –hard <code>&lt;commit&gt;</code></td><td>将当前分支回滚到指定<code>&lt;commit&gt;</code>，清除暂存区的修改，并强制删除所有工作区的修改</td></tr><tr><td><strong>GIT REBASE</strong></td><td><strong>GIT变基命令</strong></td></tr><tr><td>git rebase -i <code>&lt;base&gt;</code></td><td>以交互模式对当前分支做rebase</td></tr><tr><td><strong>GIT PULL</strong></td><td><strong>抓取远程分支命令</strong></td></tr><tr><td>git pull –rebase <code>&lt;rebase&gt;</code></td><td>抓取所有远程分支，并以rebase模式并入本地repo而不是merge</td></tr><tr><td><strong>GIT PUSH</strong></td><td><strong>推送到远程命令</strong></td></tr><tr><td>git push <code>&lt;remote&gt;</code> <strong>–force</strong></td><td>将本地分支推送到远程。不要使用–force参数，除非你完全明白此操作的后果</td></tr><tr><td>git push <code>&lt;remote&gt;</code> –tags</td><td>使用push命令并不会自动将本地tag推送到远程。加上–tags参数将会将所有本地tag推送到远程。</td></tr></tbody></table></div><hr><div class="tag_share" style="display:block"><div class="post-meta__tag-list" style="display:inline-block"><div class="article-tag"><a href="/tags/Git/"><span class="chip bg-color">Git</span></a></div></div><div class="post_share" style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css"><div id="article-share"></div></div></div><style>#reward{margin:40px 0;text-align:center}#reward .reward-link{font-size:1.4rem;line-height:38px}#reward .btn-floating:hover{box-shadow:0 6px 12px rgba(0,0,0,.2),0 5px 15px rgba(0,0,0,.2)}#rewardModal{width:320px;height:350px}#rewardModal .reward-title{margin:15px auto;padding-bottom:5px}#rewardModal .modal-content{padding:10px}#rewardModal .close{position:absolute;right:15px;top:15px;color:rgba(0,0,0,.5);font-size:1.3rem;line-height:20px;cursor:pointer}#rewardModal .close:hover{color:#ef5350;transform:scale(1.3);-moz-transform:scale(1.3);-webkit-transform:scale(1.3);-o-transform:scale(1.3)}#rewardModal .reward-tabs{margin:0 auto;width:210px}.reward-tabs .tabs{height:38px;margin:10px auto;padding-left:0}.reward-content ul{padding-left:0!important}.reward-tabs .tabs .tab{height:38px;line-height:38px}.reward-tabs .tab a{color:#fff;background-color:#ccc}.reward-tabs .tab a:hover{background-color:#ccc;color:#fff}.reward-tabs .wechat-tab .active{color:#fff!important;background-color:#22ab38!important}.reward-tabs .alipay-tab .active{color:#fff!important;background-color:#019fe8!important}.reward-tabs .reward-img{width:210px;height:210px}</style><div id="reward"><a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a><div id="rewardModal" class="modal"><div class="modal-content"><a class="close modal-close"><i class="fas fa-times"></i></a><h4 class="reward-title">给点吧！</h4><div class="reward-content"><div class="reward-tabs"><ul class="tabs row"><li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li><li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li></ul><div id="alipay"><img src="https://cdn.jsdelivr.net/gh/wangxinzhi0/PicX-image@master/createblog/alipay.ou2hknykqkg.png" class="reward-img" alt="支付宝打赏二维码"></div><div id="wechat"><img src="https://cdn.jsdelivr.net/gh/wangxinzhi0/PicX-image@master/createblog/wechat.54pag1rjudg0.png" class="reward-img" alt="微信打赏二维码"></div></div></div></div></div></div><script>$(function(){$(".tabs").tabs()})</script></div></div><style>.valine-card{margin:1.5rem auto}.valine-card .card-content{padding:20px 20px 5px 20px}#vcomments textarea{box-sizing:border-box;background:url(https://cdn.jsdelivr.net/gh/wangxinzhi0/PicX-image@master/hexo/comment_bg.xfqkznzj4w0.png) 100% 100% no-repeat}#vcomments p{margin:2px 2px 10px;font-size:1.05rem;line-height:1.78rem}#vcomments blockquote p{text-indent:.2rem}#vcomments a{padding:0 2px;color:#4cbf30;font-weight:500;text-decoration:none}#vcomments img{max-width:100%;height:auto;cursor:pointer}#vcomments ol li{list-style-type:decimal}#vcomments ol,ul{display:block;padding-left:2em;word-spacing:.05rem}#vcomments ul li,ol li{display:list-item;line-height:1.8rem;font-size:1rem}#vcomments ul li{list-style-type:disc}#vcomments ul ul li{list-style-type:circle}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}#vcomments table,td,th{border:0}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments h1{font-size:1.85rem;font-weight:700;line-height:2.2rem}#vcomments h2{font-size:1.65rem;font-weight:700;line-height:1.9rem}#vcomments h3{font-size:1.45rem;font-weight:700;line-height:1.7rem}#vcomments h4{font-size:1.25rem;font-weight:700;line-height:1.5rem}#vcomments h5{font-size:1.1rem;font-weight:700;line-height:1.4rem}#vcomments h6{font-size:1rem;line-height:1.3rem}#vcomments p{font-size:1rem;line-height:1.5rem}#vcomments hr{margin:12px 0;border:0;border-top:1px solid #ccc}#vcomments blockquote{margin:15px 0;border-left:5px solid #42b983;padding:1rem .8rem .3rem .8rem;color:#666;background-color:rgba(66,185,131,.1)}#vcomments pre{font-family:monospace,monospace;padding:1.2em;margin:.5em 0;background:#272822;overflow:auto;border-radius:.3em;tab-size:4}#vcomments code{font-family:monospace,monospace;padding:1px 3px;font-size:.92rem;color:#e96900;background-color:#f8f8f8;border-radius:2px}#vcomments pre code{font-family:monospace,monospace;padding:0;color:#e8eaf6;background-color:#272822}#vcomments pre[class*=language-]{padding:1.2em;margin:.5em 0}#vcomments code[class*=language-],pre[class*=language-]{color:#e8eaf6}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}#vcomments b,strong{font-weight:700}#vcomments dfn{font-style:italic}#vcomments small{font-size:85%}#vcomments cite{font-style:normal}#vcomments mark{background-color:#fcf8e3;padding:.2em}#vcomments table,td,th{padding:12px 13px;border:1px solid #dfe2e5}table tr:nth-child(2n),thead{background-color:#fafafa}#vcomments table th{background-color:#f2f2f2;min-width:80px}#vcomments table td{min-width:80px}#vcomments [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}</style><div class="card valine-card" data-aos="fade-up"><div class="comment_headling" style="font-size:20px;font-weight:700;position:relative;padding-left:20px;top:15px;padding-bottom:5px"><i class="fas fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div id="vcomments" class="card-content" style="display:grid"></div></div><script src="/libs/valine/av-min.js"></script><script src="/libs/valine/Valine.min.js"></script><script>new Valine({el:"#vcomments",appId:"DORpC5bDUoaXmJQyhtMU0fyi-gzGzoHsz",appKey:"gFvTRDzcAQ8FLAzRP6bLlliG",notify:!1,verify:!1,visitor:!0,avatar:"monsterid",pageSize:"10",lang:"zh-cn",placeholder:"说点什么呗"})</script><div id="to_comment" class="comment-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#vcomments" title="ֱ������"><i class="fas fa-comments"></i></a></div><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="fas fa-chevron-left"></i>&nbsp;上一篇</div><div class="card"><a href="/posts/48421.html"><div class="card-image"><img src="https://cdn.jsdelivr.net/gh/wangxinzhi0/PicX-image@master/hexo/4.ube2q32yq2o.jpg" class="responsive-img" alt="PicX图床管理和加速（Github图床）"> <span class="card-title">PicX图床管理和加速（Github图床）</span></div></a><div class="card-content article-content"><div class="summary block-with-text">Github图床，CDN加速，解决图片存储问题</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i>2021-05-08 </span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" class="post-category">个人博客</a></span></div></div><div class="card-action article-tags"><a href="/tags/%E5%9B%BE%E5%BA%8A/"><span class="chip bg-color">图床</span></a></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color">下一篇&nbsp;<i class="fas fa-chevron-right"></i></div><div class="card"><a href="/posts/45852.html"><div class="card-image"><img src="https://cdn.jsdelivr.net/gh/wangxinzhi0/PicX-image@master/hexo/10.3h8s4eyt1pu0.jpg" class="responsive-img" alt="LeetCode高频考题刷题笔记-简单"> <span class="card-title">LeetCode高频考题刷题笔记-简单</span></div></a><div class="card-content article-content"><div class="summary block-with-text">LeetCode算法刷题，高频简单题目</div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i>2021-03-14 </span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/" class="post-category">数据结构与算法刷题</a></span></div></div><div class="card-action article-tags"><a href="/tags/LeetCode-easy/"><span class="chip bg-color">LeetCode-easy</span> </a><a href="/tags/LeetCode/"><span class="chip bg-color">LeetCode</span></a></div></div></div></div></article></div><script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script><script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script><script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script><script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget card" style="background-color:#fff"><div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color"><i class="fas fa-list-ul"></i></a></div><script src="/libs/tocbot/tocbot.min.js"></script><script>$(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4, h5'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4, h5').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });</script></main><footer class="page-footer bg-color"><link rel="stylesheet" href="/libs/aplayer/APlayer.min.css"><style>.aplayer .aplayer-lrc p{font-size:13px;font-weight:1400;line-height:30px!important}.aplayer .aplayer-lrc p.aplayer-lrc-current{font-size:25px;color:#42b983}</style><div><div class="row"><meting-js class="col l8 offset-l2 m10 offset-m1 s12" server="netease" type="playlist" id="6905947490" fixed="true" autoplay theme="#42b983" loop order="list" preload="auto" volume="0.7" list-folded="true"></meting-js></div></div><script src="/libs/aplayer/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><div class="container row center-align" style="margin-bottom:15px!important"><div class="col s12 m8 l8 copy-right">Copyright&nbsp;&copy; <span id="year">2021</span> <span id="year">2021</span> <a href="/about" target="_blank">王新志</a> |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a> |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a><br>&nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span class="white-color">114k</span>&nbsp;字 |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv" class="white-color"></span>&nbsp;次 |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv" class="white-color"></span>&nbsp;人<br><span id="sitetime">载入运行时间...</span><script>function siteTime(){var e=36e5,t=24*e,n=new Date,o="2021",r=n.getFullYear(),a=n.getMonth()+1,i=n.getDate(),l=n.getHours(),m=n.getMinutes(),M=n.getSeconds(),g=Date.UTC(o,"5","20","0","0","0"),d=Date.UTC(r,a,i,l,m,M)-g,s=Math.floor(d/31536e6),u=Math.floor(d/t-365*s),T=Math.floor((d-(365*s+u)*t)/e),c=Math.floor((d-(365*s+u)*t-T*e)/6e4),f=Math.floor((d-(365*s+u)*t-T*e-6e4*c)/1e3);o==r?(document.getElementById("year").innerHTML=r,document.getElementById("sitetime").innerHTML="本站已安全运行 "+u+" 天 "+T+" 小时 "+c+" 分钟 "+f+" 秒"):(document.getElementById("year").innerHTML=o+" - "+r,document.getElementById("sitetime").innerHTML="本站已安全运行 "+s+" 年 "+u+" 天 "+T+" 小时 "+c+" 分钟 "+f+" 秒")}setInterval(siteTime,1e3)</script><br><span id="icp"><img src="/medias/icp.png" style="vertical-align:text-bottom"> <a href="http://beian.miit.gov.cn/" target="_blank">京ICP备404号</a></span></div><div class="col s12 m4 l4 social-link social-statis"><a href="https://github.com/wangxinzhi0/" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fab fa-github"></i> </a><a href="mailto:xinzhi_wang0@163.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50"><i class="fas fa-envelope-open"></i> </a><a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1761039972" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1761039972" data-position="top" data-delay="50"><i class="fab fa-qq"></i> </a><a href="https://www.zhihu.com/people/zhi-ge-38-58" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/zhi-ge-38-58" data-position="top" data-delay="50"><i class="fab fa-zhihu1">知</i> </a><a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50"><i class="fas fa-rss"></i></a></div></div></footer><div class="progress-bar"></div><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script type="text/javascript">$(function(){!function(t,s,i){"use strict";$.ajax({url:t,dataType:"xml",success:function(t){var e=$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),n=document.getElementById(s),r=document.getElementById(i);n.addEventListener("input",function(){var f='<ul class="search-result-list">',m=this.value.trim().toLowerCase().split(/[\s\-]+/);r.innerHTML="",this.value.trim().length<=0||(e.forEach(function(t){var n,e,r,s,i,l=!0,a=t.title.trim().toLowerCase(),c=t.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),u=0===(u=t.url).indexOf("/")?t.url:"/"+u,o=-1,h=-1;""!==a&&""!==c&&m.forEach(function(t,e){n=a.indexOf(t),o=c.indexOf(t),n<0&&o<0?l=!1:(o<0&&(o=0),0===e&&(h=o))}),l&&(f+="<li><a href='"+u+"' class='search-result-title'>"+a+"</a>",e=t.content.trim().replace(/<[^>]+>/g,""),0<=h&&(s=h+80,(r=h-20)<0&&(r=0),0===r&&(s=100),s>e.length&&(s=e.length),i=e.substr(r,s),m.forEach(function(t){var e=new RegExp(t,"gi");i=i.replace(e,'<em class="search-keyword">'+t+"</em>")}),f+='<p class="search-result">'+i+"...</p>"),f+="</li>")}),f+="</ul>",r.innerHTML=f)})}})}("/search.xml","searchInput","searchResult")})</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fas fa-arrow-up"></i></a></div><script src="/libs/materialize/materialize.min.js"></script><script src="/libs/masonry/masonry.pkgd.min.js"></script><script src="/libs/aos/aos.js"></script><script src="/libs/scrollprogress/scrollProgress.min.js"></script><script src="/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="/js/matery.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="/libs/others/clicklove.js" async></script><script async src="/libs/others/busuanzi.pure.mini.js"></script><script type="text/javascript" color="0,0,255" pointcolor="0,0,255" opacity="0.7" zindex="-1" count="99" src="/libs/background/canvas-nest.js"></script><script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async></script><script src="/libs/instantpage/instantpage.js" type="module"></script><script type="text/javascript" src="\js\snow.js"></script><script src="//cdn.jsdelivr.net/npm/js-base64/base64.min.js"></script><script>const hasAttr = (e,a) => a.some(_=> e.attr(_)!==undefined);
        $('a').each(function() {
          const $this = $(this);
          if(hasAttr($this,["data-fancybox","ignore-external-link"])) return;
          const href = $this.attr('href');
          if (href && href.match('^((http|https|thunder|qqdl|ed2k|Flashget|qbrowser|ftp|rtsp|mms)://)')) {
            const strs = href.split('/');
            if (strs.length >= 3) {
                const host = strs[2];
                if (host !== '' || window.location.host) {
                    $this.attr('href', '/go.html?u='+Base64.encode(href)+'').attr('rel', 'external nofollow noopener noreferrer');
                    if (true) {
                        $this.attr('target', '_blank');
                    }
                }
            }
          }
        });</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":140,"height":850},"mobile":{"show":false,"scale":0.5},"react":{"opacity":1}});</script></body></html>